# Un algorithme de tolÃ©rance aux fautes byzantines pour la Blockchain

Erik Zhang

erik@vcage.com 

## Introduction 

Cet article propose un algorithme amÃ©liorÃ© de tolÃ©rance aux fautes byzantines, ajustÃ© pour un systÃ¨me blockchain. HypothÃ©tiquement, dans ce systÃ¨me, les messages peuvent subir des pertes, des dommages, des temps de latence et des rÃ©pÃ©titions. En outre, l'ordre d'envoi n'est pas nÃ©cessairement cohÃ©rent avec l'ordre de rÃ©ception des messages. Les activitÃ©s des nÅ“uds peuvent Ãªtre arbitraires, ils peuvent rejoindre et quitter le rÃ©seau Ã  tout moment; ils peuvent aussi jeter et falsifier des informations ou simplement cesser de travailler. Des problÃ¨mes artificiels ou non artificiels peuvent Ã©galement survenir. Notre algorithme fournit une tolÃ©rance de dÃ©faut ğ‘“ = âŒŠ (ğ‘›-1) / 3 âŒ‹ Ã  un systÃ¨me de consensus qui comprend n nÅ“uds. Cette capacitÃ© de tolÃ©rance inclut la sÃ©curitÃ©, la facilitÃ© d'utilisation et convient Ã  tout environnement rÃ©seau.

## AperÃ§u 

Une blockchain est un systÃ¨me dÃ©centralisÃ© de ledger distribuÃ©. Elle pourrait Ãªtre utilisÃ©e pour l'enregistrement et l'Ã©mission d'actifs numÃ©risÃ©s, de certificats de propriÃ©tÃ©, de points de crÃ©dit, etc. Elle permet le transfert et le paiement des transactions d'une maniÃ¨re peer-to-peer. La technologie blockchain a Ã©tÃ© initialement proposÃ©e par Satoshi Nakamoto dans une liste de diffusion de cryptographie, c'est-Ã -dire le Bitcoin. Depuis de nombreuses applications basÃ©es sur la blockchain sont apparues, telles que les systÃ¨mes d'e-cash, les bourses d'actions et les systÃ¨mes Smart Contract.

Un systÃ¨me blockchain est avantageux par rapport Ã  un systÃ¨me de comptabilitÃ© centralisÃ© traditionnel pour ses caractÃ¨res d'ouverture totale, d'immuabilitÃ© et d'anti-dÃ©penses multiples, et il ne repose sur aucune sorte de tiers de confiance.

Cependant, comme tous les systÃ¨mes distribuÃ©s, les systÃ¨mes blockchain sont confrontÃ©s Ã  des problÃ¨mes de latence de rÃ©seau, d'erreurs de transmission, de bugs logiciels, de failles de sÃ©curitÃ© et de menaces de hackers Ã  chapeau noir. De plus, sa nature dÃ©centralisÃ©e suggÃ¨re qu'aucun participant du systÃ¨me ne peut Ãªtre fiable. Des nÅ“uds malveillants peuvent apparaÃ®tre, ainsi que des diffÃ©rences de donnÃ©es dues Ã  des conflits d'intÃ©rÃªts.

Pour contrer ces erreurs potentielles, un systÃ¨me blockchain a besoin d'un mÃ©canisme de consensus efficace pour s'assurer que chaque nÅ“ud possÃ¨de une copie d'une version reconnue du grand livre. Les mÃ©canismes traditionnels de tolÃ©rance aux fautes concernant certains problÃ¨mes peuvent ne pas Ãªtre complÃ¨tement capables de rÃ©soudre le problÃ¨me auquel sont confrontÃ©s les systÃ¨mes distribuÃ©s et les blockchains. Une solution de tolÃ©rance universelle aux pannes est nÃ©cessaire.

Le mÃ©canisme de preuve de travail [1], employÃ© par le Bitcoin, aborde ce problÃ¨me de maniÃ¨re plutÃ´t brillante. Mais cela a un prix, c'est-Ã -dire un coÃ»t d'Ã©lectricitÃ© et une consommation d'Ã©nergie importants. En outre, avec l'existence de Bitcoin, les nouvelles blockchains doivent trouver diffÃ©rents algorithmes de hachage, de maniÃ¨re Ã  empÃªcher les attaques par calcul. Par exemple, Litecoin adopte SCRYPT, plutÃ´t que SHA256 de Bitcoin.

Le mÃ©canisme de tolÃ©rance aux fautes byzantines est une solution universelle pour les systÃ¨mes distribuÃ©s [5]. Dans cet article, basÃ© sur la TolÃ©rance de Faute Byzantine Pratique (PBFT) [3] proposÃ©e par Castro et Liskov en 1999, un algorithme amÃ©liorÃ© de tolÃ©rance aux fautes byzantines est proposÃ© pour les systÃ¨mes blockchain.

## ModÃ¨le du systÃ¨me

Une blockchain est un systÃ¨me de ledger distribuÃ© dans lequel les participants se connectent les uns aux autres via un rÃ©seau peer-to-peer. Tous les messages qu'il contient seront envoyÃ©s par diffusion. Deux types de rÃ´les existent: les nÅ“uds ordinaires et les nÅ“uds de comptabilitÃ©. Les nÅ“uds ordinaires utilisent le systÃ¨me pour transfÃ©rer et Ã©changer, en acceptant les donnÃ©es du grand livre; tandis que les nÅ“uds de comptabilitÃ© fournissent un service de comptabilitÃ© pour l'ensemble du rÃ©seau et maintiennent le registre.

HypothÃ©tiquement, dans ce systÃ¨me, les messages peuvent subir des pertes, des dommages, des temps de latence et des rÃ©pÃ©titions. En outre, l'ordre d'envoi n'est pas nÃ©cessairement cohÃ©rent avec l'ordre de rÃ©ception des messages. Les activitÃ©s des nÅ“uds peuvent Ãªtre arbitraires, ils peuvent rejoindre et quitter le rÃ©seau Ã  tout moment; ils peuvent aussi jeter et falsifier des informations ou simplement cesser de travailler. Des problÃ¨mes artificiels ou non artificiels peuvent Ã©galement survenir.

L'intÃ©gritÃ© et l'authenticitÃ© de la transmission de l'information sont assurÃ©es avec la cryptographie tandis que les expÃ©diteurs doivent joindre des signatures Ã  la valeur de hachage du message envoyÃ©. Ici, nous dÃ©finissons <ğ‘š> <sub> Ïƒğ‘– </ sub> qui est la signature numÃ©rique du message m du nÅ“ud i, tandis que D (m) est la valeur de hachage du message m. Sans clarification particuliÃ¨re, toutes les signatures mentionnÃ©es dans cet article sont des signatures ayant la valeur de hachage du message.

## L'algorithme

Notre algorithme assure la sÃ©curitÃ© ainsi que la convivialitÃ©. Avec des nÅ“uds erronÃ©s dans le consensus ne faisant pas plus de âŒŠ (ğ‘›-1) / 3 âŒ‹, la fonctionnalitÃ© et la stabilitÃ© du systÃ¨me sont garanties. Dans cela, ğ‘› = | ğ‘… | suggÃ¨re le nombre total de nÅ“uds rejoints dans la prise de consensus alors que R reprÃ©sente l'ensemble des nÅ“uds de consensus. Ã‰tant donnÃ© que ğ‘“ = âŒŠ (ğ‘›-1) / 3 âŒ‹, f reprÃ©sente le nombre maximal de nÅ“uds erronÃ©s autorisÃ©s dans le systÃ¨me. En fait, le grand livre entier est maintenu par des nÅ“uds de comptabilitÃ© tandis que les nÅ“uds ordinaires ne participent pas Ã  la prise de consensus. Ceci est pour montrer l'ensemble des procÃ©dures de prise de consensus.

Tous les nÅ“uds de consensus sont tenus de maintenir une table d'Ã©tat pour enregistrer l'Ã©tat du consensus actuel. L'ensemble de donnÃ©es utilisÃ© pour un consensus de son dÃ©but Ã  sa fin est appelÃ© une vue. Si le consensus ne peut Ãªtre atteint dans la vue actuelle, un changement de vue sera nÃ©cessaire. Nous identifions chaque vue avec un nombre v, Ã  partir de 0 et il peut augmenter jusqu'Ã  atteindre le consensus.

Nous identifions chaque nÅ“ud de consensus avec un nombre, Ã  partir de 0, le dernier nÅ“ud est numÃ©rotÃ© n - 1. Pour chaque ronde de consensus, un nÅ“ud joue le locuteur de la maison tandis que les autres nÅ“uds jouent au CongrÃ¨s. Le nombre p du locuteur sera dÃ©terminÃ© par l'algorithme suivant: HypothÃ©tiquement, la hauteur du bloc courant est h, alors ğ‘ = (â„ - ğ‘£) ğ‘šğ‘œğ‘‘ ğ‘›, la plage de valeurs de p sera 0 â‰¤ ğ‘ <ğ‘›.

Un nouveau bloc sera gÃ©nÃ©rÃ© avec chaque ronde de consensus, avec au moins ğ‘› - ğ‘“ signatures des nÅ“uds de comptabilitÃ©. Lors de la gÃ©nÃ©ration d'un bloc, un nouveau cycle de prise de consensus doit commencer, en rÃ©initialisant v = 0.

###  ProcÃ©dures gÃ©nÃ©rales

En dÃ©finissant les intervalles de temps de gÃ©nÃ©ration de blocs comme t, dans des circonstances normales, l'algorithme s'exÃ©cute dans les procÃ©dures suivantes:

1) un nÅ“ud diffuse des donnÃ©es de transaction sur l'ensemble du rÃ©seau, joint Ã  la signature de l'expÃ©diteur;

2) tous les nÅ“uds de comptabilitÃ© surveillent la diffusion des donnÃ©es de transaction indÃ©pendamment et stockent les donnÃ©es dans leur mÃ©moire respectivement;

3) AprÃ¨s le temps t, le locuteur envoie <ğ‘ƒğ‘’ğ‘Ÿğ‘ğ‘ğ‘Ÿğ‘’ğ‘…ğ‘’ğ‘ğ‘¢ğ‘’ğ‘ ğ‘¡, â„, ğ‘£, ğ‘, ğ‘ğ‘™ğ‘œğ‘ğ‘˜, <ğ‘ğ‘™ğ‘œğ‘ğ‘˜> <sub> Ïƒğ‘ </ sub >>;

4) AprÃ¨s rÃ©ception de la proposition, les membres du CongrÃ¨s envoient <ğ‘ƒğ‘’ğ‘Ÿğ‘ğ‘ğ‘Ÿğ‘’ğ‘…ğ‘’ğ‘ ğ‘ğ‘œğ‘›ğ‘ ğ‘’, â„, ğ‘£, ğ‘–, <ğ‘ğ‘™ğ‘œğ‘ğ‘˜> <sub> Ïƒğ‘– </ sub >>;

5) Tout nÅ“ud, lorsqu'il reÃ§oit au moins ğ‘› - ğ‘“ <ğ‘ğ‘™ğ‘œğ‘ğ‘˜> <sub> Ïƒğ‘– </ sub>, parvient Ã  un consensus et publie un bloc complet;

6) Tout nÅ“ud, aprÃ¨s avoir reÃ§u le bloc complet, supprime la transaction en question de sa mÃ©moire et commence le tour suivant le consensus;

Il est nÃ©cessaire que, pour tous les nÅ“uds de consensus, au moins ğ‘› - ğ‘“ nÅ“uds soient dans le mÃªme Ã©tat d'origine. C'est-Ã -dire que pour tous les nÅ“uds i, la hauteur de bloc h et le nombre de vue v sont les mÃªmes. Ce n'est pas difficile, la cohÃ©rence de h pourrait Ãªtre atteinte en synchronisant les blocs alors que la cohÃ©rence de v pourrait Ãªtre atteinte en changeant la vue. La synchronisation de blocs n'est pas couverte dans cet article. Pour afficher le changement, consultez la section suivante.

Les nÅ“uds, aprÃ¨s avoir contrÃ´lÃ© la diffusion et reÃ§u la proposition, doivent valider les transactions. Ils ne peuvent pas Ã©crire une transaction illÃ©gale dans la mÃ©moire une fois celle-ci exposÃ©e. Si une transaction illÃ©gale est contenue dans la proposition, cette ronde de consensus sera abandonnÃ©e et le changement de vue aura lieu immÃ©diatement. Les procÃ©dures de validation sont les suivantes:

1) Le format de donnÃ©es de la transaction est-il compatible avec les rÃ¨gles du systÃ¨me? Si non, la transaction est dÃ©clarÃ©e illÃ©gale;

2) La transaction est-elle dÃ©jÃ  dans la blockchain? Si oui, la transaction est dÃ©clarÃ©e illÃ©gale;

3) Tous les scripts de contrat de la transaction sont-ils correctement exÃ©cutÃ©s? Si non, la transaction est dÃ©clarÃ©e illÃ©gale;

4) Y a-t-il plusieurs dÃ©penses dans la transaction? Si oui, la transaction est dÃ©clarÃ©e illÃ©gale;

5) Si la transaction n'a pas Ã©tÃ© jugÃ©e illÃ©gale dans les procÃ©dures ci-dessus, elle sera jugÃ©e lÃ©gale;

### Changement de vue

Si, aprÃ¨s 2 <sup> ğ‘£ + 1 </ sup> â‹… ğ‘¡ intervalle de temps, les nÅ“uds ne parviennent pas Ã  un consensus ou s'ils reÃ§oivent des propositions contenant des transactions illÃ©gales, le changement d'affichage aura lieu:

1) Ã‰tant donnÃ© k = 1, ğ‘£ <sub> ğ‘˜ </ sub> = ğ‘£ + ğ‘˜;

2) Les nÅ“uds i envoient "View Change request" <ğ¶â„ğ‘ğ‘›ğ‘”ğ‘’ğ‘‰ğ‘–ğ‘’ğ‘¤, â„, ğ‘£, ğ‘–, ğ‘£ <sub> ğ‘˜ </ sub >>;

3) Lorsqu'un nÅ“ud reÃ§oit au moins ğ‘› - ğ‘“ mÃªme v <sub> k </ sub> d'un i diffÃ©rent, le changement d'affichage est terminÃ©. DÃ©finissez ğ‘£ = ğ‘£ <sub> ğ‘˜ </ sub> et la prise de consensus commence;

4) Si, aprÃ¨s 2 <sup> ğ‘£ + 1 </ sup> â‹… ğ‘¡ intervalle de temps, le changement de vue n'est pas terminÃ©, le k augmentera et retournera Ã  l'Ã©tape 2);

Avec l'augmentation de k, le temps d'attente augmentera de faÃ§on exponentielle, de sorte que les changements de vue frÃ©quents seront Ã©vitÃ©s et que les nÅ“uds seront invitÃ©s Ã  atteindre la cohÃ©rence sur v.

Avant la fin de la modification de la vue, la vue v d'origine est toujours valide, ce qui permet d'Ã©viter toute modification inutile de la vue provoquÃ©e par une latence rÃ©seau occasionnelle.

### Organigramme

![](~/assets/consensus_flowchart.jpg)

## CapacitÃ© de tolÃ©rance aux pannes

Notre algorithme fournit _f_ = âŒŠ (ğ‘›-1) / 3 tolÃ©rance aux pannes Ã  un systÃ¨me de consensus qui comprend n nÅ“uds. Cette capacitÃ© de tolÃ©rance inclut la sÃ©curitÃ©, la convivialitÃ© et est une suite pour tout environnement rÃ©seau.

Les donnÃ©es de requÃªte provenant de nÅ“uds contiennent des signatures d'expÃ©diteur, de sorte que les nÅ“uds de tenue de livres malveillants ne peuvent pas falsifier les demandes. Au lieu de cela, ils essaieront de revenir sur l'Ã©tat du systÃ¨me, forÃ§ant le systÃ¨me Ã  s'interrompre.

HypothÃ©tiquement, dans l'environnement rÃ©seau du systÃ¨me, les nÅ“uds de consensus sont divisÃ©s en trois parties: ğ‘… = ğ‘…1 âˆª ğ‘…2 âˆª ğ¹, et ğ‘…1 âˆ© ğ‘…2 = âˆ…, ğ‘…1 âˆ© ğ¹ = âˆ…, ğ‘…2 âˆ© ğ¹ = âˆ…. Ainsi hypothÃ©tiquement,
R1 et R2 sont tous deux des nÅ“uds de tenue de livres honnÃªtes dans un silo d'information qui ne peuvent communiquer qu'avec les nÅ“uds  de leur ensemble; F sont tous des nÅ“uds malveillants en coordination; de plus, la condition de rÃ©seau de F leur permet de communiquer avec n'importe quel nÅ“ud, y compris R1 et R2.
Si F souhaite "forker" le systÃ¨me, il doit parvenir Ã  un consensus avec R1 et publier des blocs, et
puis atteindre un second consensus sans informer le R2, rÃ©voquant le consensus avec R1.
Pour y parvenir, il faut que | ğ‘…1 | + | ğ¹ | â‰¥ ğ‘› - ğ‘“ et | ğ‘…2 | + | ğ¹ | â‰¥ ğ‘› - ğ‘“.
Dans le pire des cas, | ğ¹ | = ğ‘“, c'est-Ã -dire que le nombre de nÅ“uds malveillants est au maximum de ce que le systÃ¨me pourrait tolÃ©rer et que la relation susmentionnÃ©e devienne | ğ‘…1 | â‰¥ ğ‘› - 2ğ‘“ et | ğ‘…2 | â‰¥ ğ‘› - 2ğ‘“. AjoutÃ© ensemble, | ğ‘…1 | + | ğ‘…2 | â‰¥ 2ğ‘› - 4ğ‘“, ce qui pourrait Ãªtre simplifiÃ© comme ğ‘› â‰¤ 3ğ‘“. Ã‰tant donnÃ© que ğ‘“ = âŒŠ (ğ‘›-1) / 3 âŒ‹, ce qui est en contradiction avec le premier, il peut Ãªtre prouvÃ© que le systÃ¨me ne peut pas Ãªtre forkÃ© dans la plage de tolÃ©rance.

## RÃ©ferences 

[1] Nakamoto S. Bitcoin: A peer-to-peer electronic cash system[J]. 2008. 

[2] Lamport L, Shostak R, Pease M. The Byzantine generals problem[J]. ACM Transactions on Programming Languages and Systems (TOPLAS), 1982, 4(3): 382-401. 

[3] Castro M, Liskov B. Practical Byzantine fault tolerance[C]//OSDI. 1999, 99: 173 186.

[4] Bracha G, Toueg S. Asynchronous consensus and broadcast protocols[J]. Journal of the ACM (JACM), 1985, 32(4): 824-840. 

[5] èŒƒæ·, æ˜“ä¹å¤©, èˆ’ç»§æ­¦. æ‹œå åº­ç³»ç»ŸæŠ€æœ¯ç ”ç©¶ç»¼è¿°[J]. è½¯ä»¶å­¦æŠ¥, 2013, 6: 012. 

