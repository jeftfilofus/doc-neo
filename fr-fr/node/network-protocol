# Protocole réseau


NEO adopte une structure de réseau P2P, dans laquelle les nœuds peuvent communiquer les uns avec les autres via le protocole TCP / IP. Dans cette structure, il existe deux types de nœuds différents: les nœuds d'échanges et les nœuds de validation (appelés Bookkeepers dans le livre blanc NEO). Les nœuds d'échanges peuvent diffuser, recevoir et transférer des transactions ou des blocs, tandis que la validation du nœud peut créer des blocs.

Le protocole réseau de NEO est à peu près similaire à celui de bitcoin, cependant, les structures de données telles que les blocs ou les transactions sont très différentes.

Convention
----

1. Ordre des Bytes

    Tous les types entiers de NEO sont "Little Endian" sauf pour l'adresse IP et le numéro de port, ces 2 sont "Big Endian".

1. Hash

   Deux fonctions de hachage différentes sont utilisées dans NEO: SHA256 et RIPEMD160. SHA256 est utilisé pour générer une valeur de hachage longue et RIPEMD160 est utilisé pour générer une valeur de hachage courte. En général, nous obtenons la valeur de hachage d'un objet en utilisant deux fois la fonction de hachage. Par exemple, nous utilisons deux fois SHA256 lorsque nous voulons générer la valeur de hachage d'un bloc ou d'une transaction. Lors de la génération d'une adresse de contrat, nous allons d'abord utiliser la fonction SHA256, puis utiliser RIPEMD160.
     
   En outre, le bloc utilisera également une structure de hachage appelée Arbre de Merkle. Il calcule le hachage de chaque transaction et se combine les uns avec les autres, puis répète ce processus jusqu'à ce qu'il n'y ait plus qu'un seul hash racine (Racine de Merkle).
    
1. Longueur et type de la variable

   + Variante: Entier de longueur variable qui peut être encodé pour économiser de l'espace en fonction de la valeur tapée.

      |Valeur|Longueur|Format|
      |---|---|---|
      |< 0xfd|1|uint8|
      |<= 0xffff|3|0xfd + uint16|
      |<= 0xffffffff|5|0xfe + uint32|
      |> 0xffffffff|9|0xff + uint64|

   + Varstr: "String" de longueur variable, composée d'entier de longueur variable suivi de chaînes. "String'" encodée par UTF8.

      |Taille|Champ|Type de donnée|Description|
      |---|---|---|---|
      |?|longueur|variant|longueur d'une chaine en bytes|
      |longueur|string|uint8[longueur]|"String" elle-même|

   + Array: Le tableau est constitué d'une longueur variable d'entiers suivi d'une séquence d'éléments.

1. Numéro à virgule fixe

   Les données dans NEO telles que le montant ou le prix sont des nombres à virgule fixe de 64 bits et la précision de la partie décimale est de 10 <sup> -8 </ sup>, intervalle: [- 2 <sup> 63 </ sup> / 10 <sup > 8 </ sup>, +2 <sup> 63 </ sup> / 10 <sup> 8 </ sup>

Type de données
-------

1. Blockchain

   La blockchain est une sorte de structure logique, qui est connectée en série avec une liste chaînée unidirectionnelle. Elle est utilisée pour stocker les données de l'ensemble du réseau, telles que les transactions ou les actifs.

1. "Block"

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |4|Version|uint32|Version du "block" qui est 0 pour le moment|
   |32|PrevBlock|uint256|Valeur de hachage du bloc précédent|
   |32|MerkleRoot|uint256|"Root hash" d'une liste de transactions|
   |4|Timestamp|uint32|Horodatage|
   |4|Height|uint32|Hauteur du block|
   |8|Nonce|uint64|Nombre aléatoire|
   |20|NextMiner|uint160|Adresse du contrat du prochain miner|
   |1|-|uint8|fixé à 1|
   |?|Script|script|Script utilisé pour valider le bloc|
   |?*?|Transactions|tx[]|Liste des transactions|

   Lors du calcul de la valeur de hachage du bloc, au lieu de calculer le bloc entier, seuls les sept premiers champs de la tête de bloc seront calculés: PrevBlock, MerkleRoot, horodatage et height, le nonce, NextMiner. Puisque MerkleRoot contient déjà la valeur de hachage de toutes les transactions, la modification de transaction influencera la valeur de hachage du bloc.
   
   Structure de données de la tête de bloc:

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |4|Version|uint32|Version du bloc qui est 0 pour le moment|
   |32|PrevBlock|uint256|Valeur de hachage du bloc précédent|
   |32|MerkleRoot|uint256|"Root hash" d'une liste de transactions|
   |4|Timestamp|uint32|Horodatage|
   |4|Height|uint32|Hauteur du block|
   |8|Nonce|uint64|Nombre aléatoire|
   |20|NextMiner|uint160|Adresse du contrat du prochain miner|
   |1|-|uint8|fixé à 1|
   |?|Script|script|Script utilisé pour valider le bloc|
   |1|-|uint8|Fixé à 0|

   L'horodatage de chaque bloc doit être antérieur à l'horodatage du bloc précédent. Généralement, la différence d'horodatage de deux blocs est d'environ 15 secondes et l'imprécision est autorisée. La hauteur du bloc doit être exactement égale à la hauteur du bloc précédent plus 1.

1. Transaction

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |1|Type|uint8|Type de transaction|
   |1|Version|uint8|"Trading version", actuellement 0|
   |?|-|-|Données spécifiques aux types d'opérations|
   |?*?|Attributes|tx_attr[]|Caractéristiques supplémentaires que la transaction a|
   |34*?|Inputs|tx_in[]|Entrée|
   |60*?|Outputs|tx_out[]|Sortie|
   |?*?|Scripts|script[]|Liste des scripts utilisés pour valider la transaction|

   Tous les processus du système NEO sont enregistrés en tant que transactions. Il y a plusieurs types de transactions:

   |Valeur|Nom|Frais du système|Description|
   |---|---|---|---|
   |0x00|MinerTransaction|0|Attribuer des frais de bytes|
   |0x01|IssueTransaction|500\|0|Insertion d'actif|
   |0x02|ClaimTransaction|0|Assigner GAS|
   |0x20|EnrollmentTransaction|1000|Inscription pour le validateur|
   |0x40|RegisterTransaction|10000|Registre des actifs|
   |0x80|ContractTransaction|0|Transaction de contrat|
   |0xd0|PublishTransaction|500 * n|(Non utilisable) Opérations spéciales pour les contrats intelligents|
   |0xd1|InvocationTransaction|0|Transactions spéciales pour appeler Smart Contracts|

   Chaque type de transaction, en plus du domaine public, a également son propre domaine exclusif. Ce qui suit décrira ces champs exclusifs en détail.

   + MinerTransaction

      |Taille|Champ|Type de données|Description|
      |---|---|---|---|
      |4|Nonce|uint32|nombre aléatoire|

      La première transaction dans chaque bloc doit être MinerTransaction. Il est utilisé pour récompenser tous les frais de transaction du bloc actuel au validateur.

      Le nombre aléatoire dans la transaction est utilisé pour éviter la collision de hachage

   + IssueTransaction

      Il n'y a pas de champs spéciaux pour une émission de transaction.

      Les gestionnaires d'actifs peuvent créer les actifs qui ont été enregistrés dans la chaîne de blocs de NEO via IssueTransaction, et les envoyer à n'importe quelle adresse.

      En particulier, si les actifs qui sont émis sont NEO, alors la transaction sera envoyée gratuitement.

      Le nombre aléatoire dans la transaction est utilisé pour éviter la collision de hachage

   + ClaimTransaction

      |Taille|CHamp|Type de donnée|Description|
      |---|---|---|---|
      |34*?|Claims|tx_in[]|NEO pour la distribution|

   + EnrollmentTransaction

      |Taille|Champ|Type de données|Description|
      |---|---|---|---|
      |33|PublicKey|ec_point|clé publique du validateur|

      La transaction représente un formulaire d'inscription, qui indique que le sponsor de la transaction souhaite s'inscrire en tant que validateur.

      Le moyen de s'inscrire est le suivant: Construire un type de transaction EnrollmentTransaction et envoyer un dépôt à l'adresse de PublicKey.

      Le moyen d'annuler l'inscription est: Dépenser le dépôt sur l'adresse de la clé publique.

   + RegisterTransaction

      > [!Avertissement]
      A été désactivé et remplacé par Neo.Asset.Create pour le "Smart Contract".

      Voir [Alternative .NET Smart Contract Framework](../sc/fw/dotnet/neo/Asset/Create.md)

      Voir [Alternative Smart Contract API](../sc/api/neo.md)

   + ContractTransaction

      Il n'y a pas d'attributs spéciaux pour une transaction contractuelle. C'est un type de transaction très courant car il permet à un porte-monnaie d'envoyer un NEO à un autre. Les champs de transaction `inputs` et` outputs` seront généralement importants pour cette transaction (par exemple, pour déterminer la quantité de NEO qui sera envoyée et à quelle adresse).
   
   + PublishTransaction

      > [!Warning]
       A été désactivé et remplacé par Neo.Asset.Create pour le "Smart Contract".

      Voir [Alternative .NET Smart Contract Framework](../sc/fw/dotnet/neo/Contract/Create.md)

      Voir [Alternative Smart Contract API](../sc/api/neo.md)

   + Invoquer une transaction

      | Taille   | Champ     | Type de données    | Description              |
      | ---- | ------ | ------- | --------------- |
      | -    | -      | -       | Champs publics pour les transactions       |
      | ?    | Script | uint8[] | Invoqué par un "Smart Contract"     |
      | 8    | Gas    | int64   | Coûts pour exécuter le  "Smart Contract" |
      | -    | -      | -       | Champs publics pour les transactions         |

1. Transaction Attributes

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |1|Usage|uint8|Usage|
   |0\|1|length|uint8|Longueur des données (les circonstances spécifiques seront omises)|
   |length|Data|uint8[longueur]|Données externe|

   Parfois, la transaction contiendra certaines données à usage externe, ces données seront placées dans le champ des attributs de la transaction.

   Chaque attribut de transaction a des usages différents:

   |Valeur|Nom|Description|
   |---|---|---|
   |0x00|ContractHash|Valeur de hachage du contrat|
   |0x02-0x03|ECDH02-ECDH03|Clé publique pour l'échange de clés ECDH|
   |0x20|Script|Validation supplémentaire des transactions|
   |0x30|Vote|Pour voter |
   |0x80|CertUrl|Adresse URL du certificat|
   |0x81|DescriptionUrl|Adresse URL de la description|
   |0x90|Description|Brève description|
   |0xa1-0xaf|Hash1-Hash15|Utilisé pour stocker des valeurs de hachage personnalisées|
   |0xf0-0xff|Remark-Remark15|Remarques|

   Pour ContractHash, série ECDH, série Hash, la longueur des données est fixée à 32 bytes et le champ longueur est omis;

   Pour CertUrl, DescriptionUrl, Description, Remarque série, la longueur des données doit être clairement définie, et la longueur ne doit pas dépasser 255;

1. Input of Transaction

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |32|PrevHash|uint256|Previous transaction's hash|
   |2|PrevIndex|uint16|Previous transaction's index|

1. Output of Transaction

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |32|AssetId|uint256|Asset id|
   |8|Value|int64|Value|
   |20|ScriptHash|uint160|Address of remittee|

   Each transaction can have outputs up to 65536.

1. Validation Script

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |?|StackScript|uint8[]|Stack script code|
   |?|RedeemScript|uint8[]|Contract script code|

   Stack script can only be used for the PUSH operations, which is used to push data like signatures into the stack. The script interpreter will execute the stack script code first, and then execute the contract script code.

   In a transaction, the hash value of the contract script code must be consistent with the transaction output, which is part of the validation. The later section will describe the execution process of the script in detail.

Network Message
-------

All network messages are sent in this structure:

|Size|Field|DataType|Description|
|---|---|---|---|
|4|Magic|uint32|Protocol ID|
|12|Command|char[12]|Command|
|4|length|uint32|Length of payload|
|4|Checksum|uint32|Checksum|
|length|Payload|uint8[length]|Content of message|

Defined Magic value:

|Value|Description|
|---|---|
|0x00746e41|Production mode|
|0x74746e41|Test mode|

Command is utf8 code, of which the length is 12 bytes, the extra part is filled with 0.

Checksum is the first 4 bytes of the value that two times SHA256 hash of the Payload.

According to different orders Payload has different detailed format, see below:

1. version

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |4|Version|uint32|Version of protocol, 0 for now|
   |8|Services|uint64|The service provided by the node is currently 1|
   |4|Timestamp|uint32|Current time|
   |2|Port|uint16|Port that the server is listening on, it's 0 if not used.|
   |4|Nonce|uint32|It's used to distinguish the node from public IP|
   |?|UserAgent|varstr|Client ID|
   |4|StartHeight|uint32|Height of block chain|
   |1|Relay|bool|Whether to receive and forward


   When a node receives a connection request, it declares its version immediately. There will be no other communication until both sides are getting versions of each other.

1. verack

   When a node receives the version message, it replies with a verack immediately.

   This message has no payload.

1. getaddr

   Make requests to a node for a batch of new active nodes in order to increase the number of connections.

   This message has no payload.

1. addr

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |30*?|AddressList|net_addr[]|Other nodes' address in network|

   After receiving the getaddr message, the node returns an addr message as response and provides information about the known nodes on the network.

1. getheaders

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |32*?|HashStart|uint256[]|Hash of latest block that node requests|
   |32|HashStop|uint256|Hash of last block that node requests|

   Make requests to a node for at most 2000 blocks’ header packages that contain HashStart to HashStop. To get the block hash after that, you need to resend the getheaders message. This message is used to quickly download the blockchain which does not contain the transactions.

1. headers

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |?*?|Headers|header[]|Head of the block|

   After receiving the getheaders message, the node returns a header message as response and provides information about the known nodes on the network.

1. getblocks

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |32*?|HashStart|uint256[]|Hash of latest block that node requests|
   |32|HashStop|uint256|Hash of last block that node requests|

   Make requests to a node for inv message which starts from HashStart to HashStop. The number of blocks which starts from HashStart to HashStop is up to 500. If you want to get block hash more than that, you need to resend getblocks message.

1. inv

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |36*?|Inventories|inv_vect[]|Data of inventories|

   The node can broadcast the object information it owns by this message. The message can be sent automatically or can be used to answer getblocks messages.

   Object information is included in the list:

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |4|Type|uint32|Type of object|
   |32|Hash|uint256|Hash of object|

   Object types:

   |Value|Name|Description|
   |---|---|---|
   |0x01|TX|Transaction|
   |0x02|Block|Block|
   |0xe0|Consensus|Consensus data|

1. getdata

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |36*?|Inventories|inv_vect[]|Data of inventories|

   To request a specified object from a node: It is usually sent after the inv packet is received and the known element removed.

1. block

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |?|Block|block|Block|

   Sending a block to a node, to respond to the getdata message.

1. tx

   |Size|Field|DataType|Description|
   |---|---|---|---|
   |?|Transaction|tx|Transaction|

   Sending a transaction to a node, to respond to the getdata message.

   |Size|field|data type|description|
   |----|---------|--------- |----------------- |
   |32 *?|HashStart|uint256[]|Node is known as the latest block hash|
   |32|hashStop|uint256|Request the last block|
