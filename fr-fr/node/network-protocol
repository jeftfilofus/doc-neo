# Protocole réseau


NEO adopte une structure de réseau P2P, dans laquelle les nœuds peuvent communiquer les uns avec les autres via le protocole TCP / IP. Dans cette structure, il existe deux types de nœuds différents: les nœuds d'échanges et les nœuds de validation (appelés Bookkeepers dans le livre blanc NEO). Les nœuds d'échanges peuvent diffuser, recevoir et transférer des transactions ou des blocs, tandis que la validation du nœud peut créer des blocs.

Le protocole réseau de NEO est à peu près similaire à celui de bitcoin, cependant, les structures de données telles que les blocs ou les transactions sont très différentes.

Convention
----

1. Ordre des Bytes

    Tous les types entiers de NEO sont "Little Endian" sauf pour l'adresse IP et le numéro de port, ces 2 sont "Big Endian".

1. Hash

   Deux fonctions de hachage différentes sont utilisées dans NEO: SHA256 et RIPEMD160. SHA256 est utilisé pour générer une valeur de hachage longue et RIPEMD160 est utilisé pour générer une valeur de hachage courte. En général, nous obtenons la valeur de hachage d'un objet en utilisant deux fois la fonction de hachage. Par exemple, nous utilisons deux fois SHA256 lorsque nous voulons générer la valeur de hachage d'un bloc ou d'une transaction. Lors de la génération d'une adresse de contrat, nous allons d'abord utiliser la fonction SHA256, puis utiliser RIPEMD160.
     
   En outre, le bloc utilisera également une structure de hachage appelée Arbre de Merkle. Il calcule le hachage de chaque transaction et se combine les uns avec les autres, puis répète ce processus jusqu'à ce qu'il n'y ait plus qu'un seul hash racine (Racine de Merkle).
    
1. Longueur et type de la variable

   + Variante: Entier de longueur variable qui peut être encodé pour économiser de l'espace en fonction de la valeur tapée.

      |Valeur|Longueur|Format|
      |---|---|---|
      |< 0xfd|1|uint8|
      |<= 0xffff|3|0xfd + uint16|
      |<= 0xffffffff|5|0xfe + uint32|
      |> 0xffffffff|9|0xff + uint64|

   + Varstr: "String" de longueur variable, composée d'entier de longueur variable suivi de chaînes. "String'" encodée par UTF8.

      |Taille|Champ|Type de donnée|Description|
      |---|---|---|---|
      |?|longueur|variant|longueur d'une chaine en bytes|
      |longueur|string|uint8[longueur]|"String" elle-même|

   + Array: Le tableau est constitué d'une longueur variable d'entiers suivi d'une séquence d'éléments.

1. Numéro à virgule fixe

   Les données dans NEO telles que le montant ou le prix sont des nombres à virgule fixe de 64 bits et la précision de la partie décimale est de 10 <sup> -8 </ sup>, intervalle: [- 2 <sup> 63 </ sup> / 10 <sup > 8 </ sup>, +2 <sup> 63 </ sup> / 10 <sup> 8 </ sup>

Type de données
-------

1. Blockchain

   La blockchain est une sorte de structure logique, qui est connectée en série avec une liste chaînée unidirectionnelle. Elle est utilisée pour stocker les données de l'ensemble du réseau, telles que les transactions ou les actifs.

1. "Block"

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |4|Version|uint32|Version du "block" qui est 0 pour le moment|
   |32|PrevBlock|uint256|Valeur de hachage du bloc précédent|
   |32|MerkleRoot|uint256|"Root hash" d'une liste de transactions|
   |4|Timestamp|uint32|Horodatage|
   |4|Height|uint32|Hauteur du block|
   |8|Nonce|uint64|Nombre aléatoire|
   |20|NextMiner|uint160|Adresse du contrat du prochain miner|
   |1|-|uint8|fixé à 1|
   |?|Script|script|Script utilisé pour valider le bloc|
   |?*?|Transactions|tx[]|Liste des transactions|

   Lors du calcul de la valeur de hachage du bloc, au lieu de calculer le bloc entier, seuls les sept premiers champs de la tête de bloc seront calculés: PrevBlock, MerkleRoot, horodatage et height, le nonce, NextMiner. Puisque MerkleRoot contient déjà la valeur de hachage de toutes les transactions, la modification de transaction influencera la valeur de hachage du bloc.
   
   Structure de données de la tête de bloc:

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |4|Version|uint32|Version du bloc qui est 0 pour le moment|
   |32|PrevBlock|uint256|Valeur de hachage du bloc précédent|
   |32|MerkleRoot|uint256|"Root hash" d'une liste de transactions|
   |4|Timestamp|uint32|Horodatage|
   |4|Height|uint32|Hauteur du block|
   |8|Nonce|uint64|Nombre aléatoire|
   |20|NextMiner|uint160|Adresse du contrat du prochain miner|
   |1|-|uint8|fixé à 1|
   |?|Script|script|Script utilisé pour valider le bloc|
   |1|-|uint8|Fixé à 0|

   L'horodatage de chaque bloc doit être antérieur à l'horodatage du bloc précédent. Généralement, la différence d'horodatage de deux blocs est d'environ 15 secondes et l'imprécision est autorisée. La hauteur du bloc doit être exactement égale à la hauteur du bloc précédent plus 1.

1. Transaction

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |1|Type|uint8|Type de transaction|
   |1|Version|uint8|"Trading version", actuellement 0|
   |?|-|-|Données spécifiques aux types d'opérations|
   |?*?|Attributes|tx_attr[]|Caractéristiques supplémentaires que la transaction a|
   |34*?|Inputs|tx_in[]|Entrée|
   |60*?|Outputs|tx_out[]|Sortie|
   |?*?|Scripts|script[]|Liste des scripts utilisés pour valider la transaction|

   Tous les processus du système NEO sont enregistrés en tant que transactions. Il y a plusieurs types de transactions:

   |Valeur|Nom|Frais du système|Description|
   |---|---|---|---|
   |0x00|MinerTransaction|0|Attribuer des frais de bytes|
   |0x01|IssueTransaction|500\|0|Insertion d'actif|
   |0x02|ClaimTransaction|0|Assigner GAS|
   |0x20|EnrollmentTransaction|1000|Inscription pour le validateur|
   |0x40|RegisterTransaction|10000|Registre des actifs|
   |0x80|ContractTransaction|0|Transaction de contrat|
   |0xd0|PublishTransaction|500 * n|(Non utilisable) Opérations spéciales pour les contrats intelligents|
   |0xd1|InvocationTransaction|0|Transactions spéciales pour appeler Smart Contracts|

   Chaque type de transaction, en plus du domaine public, a également son propre domaine exclusif. Ce qui suit décrira ces champs exclusifs en détail.

   + MinerTransaction

      |Taille|Champ|Type de données|Description|
      |---|---|---|---|
      |4|Nonce|uint32|nombre aléatoire|

      La première transaction dans chaque bloc doit être MinerTransaction. Il est utilisé pour récompenser tous les frais de transaction du bloc actuel au validateur.

      Le nombre aléatoire dans la transaction est utilisé pour éviter la collision de hachage

   + IssueTransaction

      Il n'y a pas de champs spéciaux pour une émission de transaction.

      Les gestionnaires d'actifs peuvent créer les actifs qui ont été enregistrés dans la chaîne de blocs de NEO via IssueTransaction, et les envoyer à n'importe quelle adresse.

      En particulier, si les actifs qui sont émis sont NEO, alors la transaction sera envoyée gratuitement.

      Le nombre aléatoire dans la transaction est utilisé pour éviter la collision de hachage

   + ClaimTransaction

      |Taille|CHamp|Type de donnée|Description|
      |---|---|---|---|
      |34*?|Claims|tx_in[]|NEO pour la distribution|

   + EnrollmentTransaction

      |Taille|Champ|Type de données|Description|
      |---|---|---|---|
      |33|PublicKey|ec_point|clé publique du validateur|

      La transaction représente un formulaire d'inscription, qui indique que le sponsor de la transaction souhaite s'inscrire en tant que validateur.

      Le moyen de s'inscrire est le suivant: Construire un type de transaction EnrollmentTransaction et envoyer un dépôt à l'adresse de PublicKey.

      Le moyen d'annuler l'inscription est: Dépenser le dépôt sur l'adresse de la clé publique.

   + RegisterTransaction

      > [!Avertissement]
      A été désactivé et remplacé par Neo.Asset.Create pour le "Smart Contract".

      Voir [Alternative .NET Smart Contract Framework](../sc/fw/dotnet/neo/Asset/Create.md)

      Voir [Alternative Smart Contract API](../sc/api/neo.md)

   + ContractTransaction

      Il n'y a pas d'attributs spéciaux pour une transaction contractuelle. C'est un type de transaction très courant car il permet à un porte-monnaie d'envoyer un NEO à un autre. Les champs de transaction `inputs` et` outputs` seront généralement importants pour cette transaction (par exemple, pour déterminer la quantité de NEO qui sera envoyée et à quelle adresse).
   
   + PublishTransaction

      > [!Warning]
       A été désactivé et remplacé par Neo.Asset.Create pour le "Smart Contract".

      Voir [Alternative .NET Smart Contract Framework](../sc/fw/dotnet/neo/Contract/Create.md)

      Voir [Alternative Smart Contract API](../sc/api/neo.md)

   + Invoquer une transaction

      | Taille   | Champ     | Type de données    | Description              |
      | ---- | ------ | ------- | --------------- |
      | -    | -      | -       | Champs publics pour les transactions       |
      | ?    | Script | uint8[] | Invoqué par un "Smart Contract"     |
      | 8    | Gas    | int64   | Coûts pour exécuter le  "Smart Contract" |
      | -    | -      | -       | Champs publics pour les transactions         |

1. Transaction Attributes

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |1|Usage|uint8|Usage|
   |0\|1|length|uint8|Longueur des données (les circonstances spécifiques seront omises)|
   |length|Data|uint8[longueur]|Données externe|

   Parfois, la transaction contiendra certaines données à usage externe, ces données seront placées dans le champ des attributs de la transaction.

   Chaque attribut de transaction a des usages différents:

   |Valeur|Nom|Description|
   |---|---|---|
   |0x00|ContractHash|Valeur de hachage du contrat|
   |0x02-0x03|ECDH02-ECDH03|Clé publique pour l'échange de clés ECDH|
   |0x20|Script|Validation supplémentaire des transactions|
   |0x30|Vote|Pour voter |
   |0x80|CertUrl|Adresse URL du certificat|
   |0x81|DescriptionUrl|Adresse URL de la description|
   |0x90|Description|Brève description|
   |0xa1-0xaf|Hash1-Hash15|Utilisé pour stocker des valeurs de hachage personnalisées|
   |0xf0-0xff|Remark-Remark15|Remarques|

   Pour ContractHash, série ECDH, série Hash, la longueur des données est fixée à 32 bytes et le champ longueur est omis;

   Pour CertUrl, DescriptionUrl, Description, Remarque série, la longueur des données doit être clairement définie, et la longueur ne doit pas dépasser 255;

1. "Input" d'une transaction

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |32|PrevHash|uint256|Hash de la transaction précédente|
   |2|PrevIndex|uint16|Index de la transaction précédente|

1. "Output" d'une transaction

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |32|AssetId|uint256|Identifiant de l'actif|
   |8|Value|int64|Valeur|
   |20|ScriptHash|uint160|Address du membre|

   Chaque transaction peut avoir jusqu'à 65536 sorties.

1. Script de validation

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |?|StackScript|uint8[]|Pile script code|
   |?|RedeemScript|uint8[]|Contrat script code|

   Le script de pile ne peut être utilisé que pour les opérations PUSH, qui sont utilisées pour pousser des données comme des signatures dans la pile. L'interpréteur de script exécutera d'abord le code de script de la pile, puis exécutera le code du script de contrat.

   Dans une transaction, la valeur de hachage du code du script de contrat doit être cohérente avec la sortie de la transaction, qui fait partie de la validation. La section suivante décrira le processus d'exécution du script en détail.

Messages du réseau
-------

Tous les messages réseau sont envoyés dans cette structure:

|Taille|Champ|Type de donnée|Description|
|---|---|---|---|
|4|Magic|uint32|ID du protocole|
|12|Command|char[12]|Commande|
|4|length|uint32|Longueur de la charge utile|
|4|Checksum|uint32|"Checksum"|
|length|Payload|uint8[length]|Contenu du message|

Valeur magique définie:

|Valeur|Description|
|---|---|
|0x00746e41|Mode production|
|0x74746e41|Mode Test|

La commande est un code utf8, dont la longueur est de 12 bytes, la partie supplémentaire est remplie avec 0.

Checksum est les premier 4 byte de la valeur de deux fois la fonction hachage SHA256 de la charge utile.

Selon différentes commandes la charge utile a différents formats détaillés, voir ci-dessous:

1. version

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |4|Version|uint32|Version du protocole, 0 pour le moment|
   |8|Services|uint64|Le service fourni par le noeud est actuellement 1|
   |4|Timestamp|uint32|Heure actuelle|
   |2|Port|uint16|Port que le serveur écoute, 0 s'il n'est pas utilisé|
   |4|Nonce|uint32|Permet de distinguer le noeud de l'adresse IP publique|
   |?|UserAgent|varstr|ID client|
   |4|StartHeight|uint32|Hauteur de la chaîne de blocs|
   |1|Relay|bool|Que recevoir et transférer|


   Lorsqu'un nœud reçoit une requête de connexion, il déclare sa version immédiatement. Il n'y aura pas d'autre communication avant que les deux parties n'obtiennent la version les unes des autres.

1. verack

   Lorsqu'un nœud reçoit le message de la version, il répond immédiatement avec un verack.

   Ce message n'a aucune charge utile.

1. getaddr

   Faire des demandes à un nœud pour un lot de nouveaux nœuds actifs afin d'augmenter le nombre de connexions.

   Ce message n'a aucune charge utile.

1. addr

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |30*?|AddressList|net_addr[]|L'adresse d'autres noeuds dans le réseau|

   Après avoir reçu le message getaddr, le nœud renvoie un message addr comme réponse et fournit des informations sur les nœuds connus sur le réseau.

1. getheaders

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |32*?|HashStart|uint256[]|Hash du dernier bloc que le noeud demande|
   |32|HashStop|uint256|Hash du dernier bloc demandé par le noeud|

   Envoyez des demandes à un nœud pour au plus 2000 paquets d'en-tête de blocs contenant HashStart à HashStop. Pour obtenir le hachage du bloc après cela, vous devez renvoyer le message getheaders. Ce message est utilisé pour télécharger rapidement la blockchain qui ne contient pas les transactions.

1. headers

   |Taille|CHamp|Type de données|Description|
   |---|---|---|---|
   |?*?|Headers|header[]|En tête du bloc|

   Après réception du message getheaders, le nœud renvoie un message d'en-tête en réponse et fournit des informations sur les nœuds connus sur le réseau.
   
1. getblocks

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |32*?|HashStart|uint256[]|Hash du dernier bloc que le noeud demande|
   |32|HashStop|uint256|Hachure du dernier bloc demandé par le noeud|

   Faire des demandes à un nœud pour un message "inv" qui commence à partir de HashStart à HashStop. Le nombre de blocs qui va de HashStart à HashStop peut atteindre 500. Si vous voulez obtenir plus de hash, vous devez renvoyer le message getblocks.

1. inv

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |36*?|Inventories|inv_vect[]|Données sur les stocks|

   Le nœud peut diffuser les informations d'objet qu'il possède par ce message. Le message peut être envoyé automatiquement ou peut être utilisé pour répondre aux messages getblocks

   Les informations sur l'objet sont incluses dans la liste:

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |4|Type|uint32|Type d'objet|
   |32|Hash|uint256|Hash de l'objet|

   Types d'objets:

   |Valeur|Nom|Description|
   |---|---|---|
   |0x01|TX|Transaction|
   |0x02|Block|Bloc|
   |0xe0|Consensus|données de consensus|

1. getdata

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |36*?|Inventories|inv_vect[]|Données sur les stocks|

   Pour demander un objet spécifié à partir d'un noeud: Il est généralement envoyé après la réception du paquet inv et la suppression de l'élément connu.

1. block

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |?|Block|block|Bloc|

   Envoyer un bloc à un noeud pour répondre au message getdata.

1. tx

   |Taille|Champ|Type de données|Description|
   |---|---|---|---|
   |?|Transaction|tx|Transaction|

   Envoyer une transaction à un noeud, pour répondre au message getdata.

   |Taille|Champ|Type de données|description|
   |----|---------|--------- |----------------- |
   |32 *?|HashStart|uint256[]|Le noeud qui est connu comme le dernier hachage de bloc|
   |32|hashStop|uint256|Demander le dernier bloc|
